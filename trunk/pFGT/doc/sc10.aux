\relax 
\ifx\hyper@anchor\@undefined
\global \let \oldcontentsline\contentsline
\gdef \contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global \let \oldnewlabel\newlabel
\gdef \newlabel#1#2{\newlabelxx{#1}#2}
\gdef \newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\let \contentsline\oldcontentsline
\let \newlabel\oldnewlabel}
\else
\global \let \hyper@last\relax 
\fi

\citation{fgt}
\citation{greengard98}
\citation{duraiswami03}
\citation{fggt}
\citation{veerapaneni08}
\citation{fgt}
\citation{greengard98}
\citation{fggt}
\citation{fggt}
\@writefile{toc}{\contentsline {section}{\numberline {I}Introduction}{1}{section.1}}
\newlabel{s:intro}{{I}{1}{Introduction\relax }{section.1}{}}
\newlabel{gt}{{1}{1}{Introduction\relax }{equation.1.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {II}Overview of FGT}{1}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {II-A}}Truncation algorithm}{1}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {II-B}}Expansion algorithm}{1}{subsection.2.2}}
\citation{fggt}
\@writefile{toc}{\contentsline {subsection}{\numberline {\unhbox \voidb@x \hbox {II-C}}A novel scheme for translation}{2}{subsection.2.3}}
\@writefile{toc}{\contentsline {paragraph}{\numberline {\unhbox \voidb@x \hbox {II-C}0a}Accelerating the plane-wave translation step}{2}{paragraph.2.3.0.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  The outermost layer, for which the local expansions are computed directly. }}{2}{figure.1}}
\newlabel{fig:outer}{{1}{2}{\small The outermost layer, for which the local expansions are computed directly. \relax }{figure.1}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  The Contributions. }}{2}{figure.2}}
\newlabel{fig:corner2}{{2}{2}{\small The Contributions. \relax }{figure.2}{}}
\citation{fggt}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces \relax \fontsize  {9}{10pt}\selectfont  The propagation of the local expansions using neighbors. }}{3}{figure.3}}
\newlabel{fig:corner}{{3}{3}{\small The propagation of the local expansions using neighbors. \relax }{figure.3}{}}
\@writefile{toc}{\contentsline {section}{\numberline {III}Nonuniform distributions}{3}{section.3}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {1}{\ignorespaces {\em  Tree Splitting}}}{3}{algorithm.1}}
\@writefile{loa}{\contentsline {algorithm}{\numberline {2}{\ignorespaces \em  FGT on a split tree}}{3}{algorithm.2}}
\@writefile{toc}{\contentsline {section}{\numberline {IV}Results}{3}{section.4}}
\@writefile{lot}{\contentsline {table}{\numberline {I}{\ignorespaces {\rm  {\relax \fontsize  {8}{9pt}\selectfont  Timings on 37,268 ($32^3$) processors on Jaguar. The point distribution is uniform random, the parameter $\delta = 8 \times 10^{-4}$ and precision $\epsilon = 10^{-6}$}}. Each processor has a million points.}}{3}{table.1}}
\newlabel{t:scaling}{{IV}{3}{Results\relax }{table.1}{}}
\@writefile{toc}{\contentsline {section}{\numberline {V}Conclusions}{3}{section.5}}
\bibdata{sc10}
\bibcite{fggt}{1}
\bibcite{fgt}{2}
\bibcite{greengard98}{3}
\bibcite{veerapaneni08}{4}
\bibcite{duraiswami03}{5}
\bibstyle{siam}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces Strong scaling on Jaguar. The problem size is fixed to 1 billion points and the parameters are the same as defined in Table \ref  {t:scaling}. [Rahul: Try varying the num. of processors from 16 to atleast 8192]}}{4}{figure.6}}
\newlabel{f:fixed}{{6}{4}{Strong scaling on Jaguar. The problem size is fixed to 1 billion points and the parameters are the same as defined in Table \ref {t:scaling}. [Rahul: Try varying the num. of processors from 16 to atleast 8192]\relax }{figure.6}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces Weak scaling on Jaguar. Number of points per proceesor is fixed at 1 million (so $N = 10^6 \times n_p$) and the parameter $\delta = \frac  {10}{N^{1/3}}$. [Rahul: Try varying the num. of processors from 16 to atleast 8192]}}{4}{figure.7}}
\newlabel{f:iso}{{7}{4}{Weak scaling on Jaguar. Number of points per proceesor is fixed at 1 million (so $N = 10^6 \times n_p$) and the parameter $\delta = \frac {10}{N^{1/3}}$. [Rahul: Try varying the num. of processors from 16 to atleast 8192]\relax }{figure.7}{}}
\newlabel{fig:Grid1}{{4(a)}{4}{Subfigure 4(a)\relax }{subfigure.4.1}{}}
\newlabel{sub@fig:Grid1}{{(a)}{4}{Subfigure 4(a)\relax }{subfigure.4.1}{}}
\newlabel{fig:Grid2}{{4(b)}{4}{Subfigure 4(b)\relax }{subfigure.4.2}{}}
\newlabel{sub@fig:Grid2}{{(b)}{4}{Subfigure 4(b)\relax }{subfigure.4.2}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces \em  Here we illustrate one of the main steps involved in FGT. a) The leaf nodes (shown in black) of the given quadtree are assigned to regular boxes (shown in red). The size of the boxes is chosen so that each box corresponds to a node at some level of the quadtree. b) At a source box $B$, the influence of all the constituent leaf nodes is encoded in the wave expansion $\mathbf  {w}^B$. The translation operator $\mathbf  {t}^{BC}$ transfers the wave expansion of $B$ to the target box $C$. At $C$, the influence of all the source boxes in $\mathcal  {I}[C]$ is encoded in the local expansion $\mathbf  {l}^C$. Finally, $G_{\delta }f$ at a target that belongs to $C$ is given by $<\mathbf  {l}^C, \mathbf  {v}^C(\mathbf  {x})>$.}}{4}{figure.4}}
\newlabel{fig:Grid}{{4}{4}{\em Here we illustrate one of the main steps involved in FGT. a) The leaf nodes (shown in black) of the given quadtree are assigned to regular boxes (shown in red). The size of the boxes is chosen so that each box corresponds to a node at some level of the quadtree. b) At a source box $B$, the influence of all the constituent leaf nodes is encoded in the wave expansion $\mb {w}^B$. The translation operator $\mb {t}^{BC}$ transfers the wave expansion of $B$ to the target box $C$. At $C$, the influence of all the source boxes in $\mci [C]$ is encoded in the local expansion $\mb {l}^C$. Finally, $\gausst f$ at a target that belongs to $C$ is given by $<\mb {l}^C, \mb {v}^C(\mbx )>$}{figure.4}{}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces {}}}{4}{figure.4}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces {}}}{4}{figure.4}}
\@writefile{toc}{\contentsline {section}{References}{4}{section*.1}}
\newlabel{fig:Qtree0}{{5(a)}{5}{Subfigure 5(a)\relax }{subfigure.5.1}{}}
\newlabel{sub@fig:Qtree0}{{(a)}{5}{Subfigure 5(a)\relax }{subfigure.5.1}{}}
\newlabel{fig:Qtree1}{{5(b)}{5}{Subfigure 5(b)\relax }{subfigure.5.2}{}}
\newlabel{sub@fig:Qtree1}{{(b)}{5}{Subfigure 5(b)\relax }{subfigure.5.2}{}}
\newlabel{fig:Qtree2}{{5(c)}{5}{Subfigure 5(c)\relax }{subfigure.5.3}{}}
\newlabel{sub@fig:Qtree2}{{(c)}{5}{Subfigure 5(c)\relax }{subfigure.5.3}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces \em  In this figure we illustrate the tree splitting that we use in CFGT to obtain an algorithmic complexity that is independent of the value of $\delta $. Subfigure (a) shows the quadtree, a target $\mathbf  {x}$, and the support of the Gaussian centered at $\mathbf  {x}$ (blue box). For this $\delta $, we can observe that a direct evaluation would be expensive because we have to loop through all the leaf nodes within the support. A kernel expansion based approach would also be expensive because it generates too many boxes. Hence, for optimal complexity, we split the tree into two parts. Subfigure (b) shows the tree with the size of leaf nodes being greater than $r_b$. To evaluate the Gauss transform at a point $\mathbf  {x}$, we just need to visit the leaf nodes in the support of the Gaussian (the shaded ones). There can be a maximum of $(2n+1)^2$ of such leaf nodes. Subfigure (c) show the tree with the size of leaf nodes being smaller or equal than $r_b$. In this tree we use the kernel expansion-based algorithm. Instead of visiting all the leaf nodes within the support, we only have to gather the wave expansion of the source boxes (red boxes) that are within the support. The number of these source boxes is bounded from above by $(2n+1)^2$. }}{5}{figure.5}}
\newlabel{fig:qtree_split}{{5}{5}{\em In this figure we illustrate the tree splitting that we use in CFGT to obtain an algorithmic complexity that is independent of the value of $\delta $. Subfigure (a) shows the quadtree, a target $\mbx $, and the support of the Gaussian centered at $\mbx $ (blue box). For this $\delta $, we can observe that a direct evaluation would be expensive because we have to loop through all the leaf nodes within the support. A kernel expansion based approach would also be expensive because it generates too many boxes. Hence, for optimal complexity, we split the tree into two parts. Subfigure (b) shows the tree with the size of leaf nodes being greater than $r_b$. To evaluate the Gauss transform at a point $\mbx $, we just need to visit the leaf nodes in the support of the Gaussian (the shaded ones). There can be a maximum of $(2n+1)^2$ of such leaf nodes. Subfigure (c) show the tree with the size of leaf nodes being smaller or equal than $r_b$. In this tree we use the kernel expansion-based algorithm. Instead of visiting all the leaf nodes within the support, we only have to gather the wave expansion of the source boxes (red boxes) that are within the support. The number of these source boxes is bounded from above by $(2n+1)^2$. \relax }{figure.5}{}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(a)}{\ignorespaces {$Q$}}}{5}{figure.5}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(b)}{\ignorespaces {$Q_{\text {Direct}}$}}}{5}{figure.5}}
\@writefile{lof}{\contentsline {subfigure}{\numberline{(c)}{\ignorespaces {$Q_{\text {Expand}}$}}}{5}{figure.5}}
